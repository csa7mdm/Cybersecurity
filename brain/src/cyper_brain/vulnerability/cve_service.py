"""
CVE/NVD Vulnerability Intelligence Service

Integrates with NVD API to enrich scan findings with CVE data.
Following TDD - tests in test_cve_service.py
"""

import os
import logging
import requests
from dataclasses import dataclass, field
from datetime import datetime
from typing import List, Optional, Dict
from functools import lru_cache

logger = logging.getLogger(__name__)


class VulnerabilityNotFound(Exception):
    """Raised when CVE not found in database"""
    pass


@dataclass
class CVSSScore:
    """CVSS vulnerability score"""
    version: str = "3.1"
    base_score: float = 0.0
    vector_string: Optional[str] = None
    
    def get_severity(self) -> str:
        """Map score to severity level"""
        if self.base_score == 0.0:
            return "NONE"
        elif self.base_score < 4.0:
            return "LOW"
        elif self.base_score < 7.0:
            return "MEDIUM"
        elif self.base_score < 9.0:
            return "HIGH"
        else:
            return "CRITICAL"


@dataclass
class CVEData:
    """CVE vulnerability data"""
    cve_id: str
    description: str
    cvss_score: float = 0.0
    severity: str = "UNKNOWN"
    published_date: Optional[datetime] = None
    last_modified: Optional[datetime] = None
    references: List[str] = field(default_factory=list)
    affected_products: List[str] = field(default_factory=list)
    cwe_ids: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return {
            "cve_id": self.cve_id,
            "description": self.description,
            "cvss_score": self.cvss_score,
            "severity": self.severity,
            "published_date": self.published_date.isoformat() if self.published_date else None,
            "references": self.references,
            "affected_products": self.affected_products,
            "cwe_ids": self.cwe_ids
        }


class CVEService:
    """
    CVE/NVD Vulnerability Intelligence Service
    
    Provides CVE lookups and enrichment for scan findings.
    Uses NVD API 2.0: https://nvd.nist.gov/developers
    """
    
    def __init__(self, api_key: Optional[str] = None):
        """
        Initialize CVE service
        
        Args:
            api_key: NVD API key (optional, increases rate limits)
        """
        self.api_key = api_key or os.getenv("NVD_API_KEY", "")
        self.base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.session = requests.Session()
        
        if self.api_key:
            self.session.headers.update({"apiKey": self.api_key})
        
        # Rate limiting: 5 requests/30s without key, 50/30s with key
        self.rate_limit = 50 if self.api_key else 5
    
    @lru_cache(maxsize=1000)
    def lookup(self, cve_id: str) -> CVEData:
        """
        Lookup CVE by ID
        
        Args:
            cve_id: CVE identifier (e.g., CVE-2024-1234)
        
        Returns:
            CVEData object
        
        Raises:
            VulnerabilityNotFound: If CVE not found
        """
        try:
            url = f"{self.base_url}"
            params = {"cveId": cve_id}
            
            logger.info(f"Looking up {cve_id} from NVD")
            response = self.session.get(url, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            
            if not data.get("vulnerabilities"):
                raise VulnerabilityNotFound(f"CVE {cve_id} not found")
            
            cve_item = data["vulnerabilities"][0]["cve"]
            
            # Parse description
            descriptions = cve_item.get("descriptions", [])
            description = next(
                (d["value"] for d in descriptions if d["lang"] == "en"),
                "No description available"
            )
            
            # Parse CVSS score
            cvss_score = 0.0
            severity = "UNKNOWN"
            metrics = cve_item.get("metrics", {})
            
            # Try CVSS v3.1 first
            if "cvssMetricV31" in metrics:
                cvss_data = metrics["cvssMetricV31"][0]["cvssData"]
                cvss_score = float(cvss_data.get("baseScore", 0.0))
                severity = cvss_data.get("baseSeverity", "UNKNOWN")
            # Fallback to CVSS v3.0
            elif "cvssMetricV30" in metrics:
                cvss_data = metrics["cvssMetricV30"][0]["cvssData"]
                cvss_score = float(cvss_data.get("baseScore", 0.0))
                severity = cvss_data.get("baseSeverity", "UNKNOWN")
            
            # Parse references
            references = [
                ref["url"]
                for ref in cve_item.get("references", [])
            ]
            
            # Parse dates
            published = cve_item.get("published")
            published_date = datetime.fromisoformat(published.replace("Z", "+00:00")) if published else None
            
            modified = cve_item.get("lastModified")
            last_modified = datetime.fromisoformat(modified.replace("Z", "+00:00")) if modified else None
            
            # Parse CWE IDs
            cwe_ids = []
            weaknesses = cve_item.get("weaknesses", [])
            for weakness in weaknesses:
                for desc in weakness.get("description", []):
                    if desc.get("value", "").startswith("CWE-"):
                        cwe_ids.append(desc["value"])
            
            cve_data = CVEData(
                cve_id=cve_id,
                description=description,
                cvss_score=cvss_score,
                severity=severity,
                published_date=published_date,
                last_modified=last_modified,
                references=references[:5],  # Limit to 5 references
                cwe_ids=cwe_ids
            )
            
            logger.info(f"Found {cve_id}: CVSS {cvss_score} ({severity})")
            return cve_data
            
        except requests.RequestException as e:
            logger.error(f"Failed to lookup {cve_id}: {e}")
            raise
    
    def enrich_finding(self, finding: Dict) -> Dict:
        """
        Enrich a scan finding with CVE data
        
        Args:
            finding: Scan finding with optional cve_id field
        
        Returns:
            Enriched finding with CVE data
        """
        enriched = finding.copy()
        
        cve_id = finding.get("cve_id")
        if not cve_id:
            return enriched
        
        try:
            cve_data = self.lookup(cve_id)
            
            enriched.update({
                "cvss_score": cve_data.cvss_score,
                "severity": cve_data.severity,
                "cve_description": cve_data.description,
                "published_date": cve_data.published_date.isoformat() if cve_data.published_date else None,
                "references": cve_data.references,
                "cwe_ids": cve_data.cwe_ids
            })
            
        except VulnerabilityNotFound:
            logger.warning(f"CVE {cve_id} not found in NVD")
        except Exception as e:
            logger.error(f"Failed to enrich with {cve_id}: {e}")
        
        return enriched
    
    def enrich_findings(self, findings: List[Dict]) -> List[Dict]:
        """Enrich multiple findings"""
        return [self.enrich_finding(f) for f in findings]
    
    def search(
        self,
        keyword: Optional[str] = None,
        product: Optional[str] = None,
        version: Optional[str] = None,
        max_results: int = 20
    ) -> List[CVEData]:
        """
        Search CVE database
        
        Args:
            keyword: Search term
            product: Product name (CPE)
            version: Product version
            max_results: Maximum results to return
        
        Returns:
            List of CVEData objects
        """
        try:
            params = {"resultsPerPage": max_results}
            
            if keyword:
                params["keywordSearch"] = keyword
            
            if product:
                # Construct CPE name
                cpe = f"cpe:2.3:a:*:{product}"
                if version:
                    cpe += f":{version}"
                params["cpeName"] = cpe
            
            response = self.session.get(self.base_url, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            
            results = []
            for vuln in data.get("vulnerabilities", []):
                cve_item = vuln["cve"]
                cve_id = cve_item["id"]
                
                # Use cached lookup if available
                try:
                    cve_data = self.lookup(cve_id)
                    results.append(cve_data)
                except Exception:
                    continue
            
            return results
            
        except Exception as e:
            logger.error(f"Search failed: {e}")
            return []
    
    def has_known_exploit(self, cve: CVEData) -> bool:
        """
        Check if CVE has known public exploits
        
        This is a simplified check - in production, integrate with
        Exploit-DB, Metasploit, or other exploit databases
        """
        # Placeholder - would check exploit databases
        return False
    
    def check_exploits(self, cve_id: str) -> bool:
        """Check if exploits exist for CVE"""
        # Placeholder for exploit database integration
        return False
    
    def is_actively_exploited(self, cve_id: str) -> bool:
        """
        Check if CVE is in CISA Known Exploited Vulnerabilities catalog
        
        Returns True if actively exploited in the wild
        """
        try:
            kev_cves = self.get_cisa_kev()
            return cve_id in kev_cves
        except Exception:
            return False
    
    def get_cisa_kev(self) -> List[str]:
        """
        Get CISA Known Exploited Vulnerabilities
        
        Returns list of CVE IDs actively exploited
        """
        try:
            url = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            vulnerabilities = data.get("vulnerabilities", [])
            
            return [v["cveID"] for v in vulnerabilities]
            
        except Exception as e:
            logger.error(f"Failed to fetch CISA KEV: {e}")
            return []
